{"version":3,"file":"index-CMPClZuZ.js","sources":["../../../miraedojeon/front/src/pages/IntelligentCyberTargets/target/TargetGraphComp/TargetImage.jsx","../../../miraedojeon/front/src/pages/IntelligentCyberTargets/target/TargetGraphComp/TargetGraph2D.jsx","../../../miraedojeon/front/src/pages/IntelligentCyberTargets/target/TargetGraphComp/edgeStyleUtils.js"],"sourcesContent":["// TargetImage.jsx\r\n// 노드 이미지 경로를 조건에 따라 반환하는 유틸 컴포넌트\r\n\r\n\r\nconst defaultImg = '/logo192.png';\r\n\r\nconst switchImg = '/image/switch.png';\r\nconst workStationImg = '/image/workstation.png';\r\nconst serverImg = '/image/server.png';\r\nconst routerImg = '/image/router.png';\r\nconst firewallImg = '/image/firewall.png';\r\nconst laptopImg = '/image/laptop.png';\r\nconst printerImg = '/image/printer.png';\r\nconst sensorImg = '/image/sensor.png';\r\nconst plcImg = '/image/plc.png';\r\n\r\nexport function getNodeImage(node) {\r\n  // type 값에 따라 이미지 반환\r\n  if (node.type === 'switch') {\r\n    return switchImg;\r\n  } else if (node.type === 'workstation') {\r\n    return workStationImg;\r\n  } else if (node.type === 'server') {\r\n    return serverImg;\r\n  } else if (node.type === 'router') {\r\n    return routerImg;\r\n  } else if (node.type === 'firewall') {\r\n    return firewallImg;\r\n  } else if (node.type === 'laptop') {\r\n    return laptopImg;\r\n  } else if (node.type === 'printer') {\r\n    return printerImg;\r\n  } else if (node.type === 'sensor') {\r\n    return sensorImg;\r\n  } else if (node.type === 'plc') {\r\n    return plcImg;\r\n  } else {\r\n    return defaultImg;\r\n  }\r\n}\r\n\r\nexport default getNodeImage;\r\n","import React, { useEffect, useRef, useMemo, useCallback } from \"react\";\r\nimport { Network } from \"vis-network/standalone\";\r\nimport \"../Target.css\";\r\nimport getNodeImage from './TargetImage';\r\nimport { getEdgeStyle } from './edgeStyleUtils';\r\n\r\nconst TargetGraph2D = React.memo(({ dbNodes = [], onNodeClick, filterConditions }) => {\r\n  const containerRef = useRef(null);\r\n  const networkRef = useRef(null);\r\n\r\n  // dbNodes를 Vis.js 노드/엣지 데이터로 변환\r\n  const getNodeId = React.useCallback(\r\n    node => String(node?.__id ?? node?.id ?? node?.ip ?? node?.index ?? JSON.stringify(node)),\r\n    []\r\n  );\r\n  // ...width, height 변수 제거...\r\n  const { nodes, edges } = React.useMemo(() => {\r\n    const nodes = [];\r\n    const edges = [];\r\n    // 모든 edge 생성 (중복 허용, ip 상관없이)\r\n    dbNodes.forEach(item => {\r\n      if (item.edge && item.src_IP && item.dst_IP) {\r\n        const srcId = getNodeId(item.src_IP);\r\n        const dstId = getNodeId(item.dst_IP);\r\n        const degreeScore = typeof item.src_IP.degree_score === 'number' ? item.src_IP.degree_score : null;\r\n        let edgeType = 'solid';\r\n        if (degreeScore <= 0.5) edgeType = 'dashed';\r\n        if (filterConditions?.connectionType === 'direct' && !(degreeScore > 0.5)) return;\r\n        if (filterConditions?.connectionType === 'indirect' && !(degreeScore > 0 && degreeScore <= 0.5)) return;\r\n        const style = getEdgeStyle({ ...item.edge, edgeType });\r\n        edges.push({\r\n          from: srcId,\r\n          to: dstId,\r\n          length: 100 + Math.random() * 200,\r\n          ...style\r\n        });\r\n      }\r\n    });\r\n    // 모든 노드 추가 (중복 허용, ip 상관없이)\r\n    dbNodes.forEach(item => {\r\n      [item.src_IP, item.dst_IP].forEach(node => {\r\n        const nid = getNodeId(node);\r\n        if (node && !nodes.some(n => n.id === nid)) {\r\n          const imageSrc = getNodeImage(node);\r\n          const minSize = 14;\r\n          const maxSize = 50;\r\n          let score = 0.5;\r\n          if (typeof node.degree_score === 'number' && typeof node.con_score === 'number') {\r\n            score = node.degree_score + node.con_score;\r\n            score = Math.max(0, Math.min(1, score));\r\n          }\r\n          const dynamicSize = minSize + (maxSize - minSize) * score;\r\n          nodes.push({\r\n            id: nid,\r\n            label: node.label || node.ip || nid,\r\n            shape: 'image',\r\n            image: imageSrc,\r\n            size: dynamicSize\r\n          });\r\n        }\r\n      });\r\n    });\r\n    return { nodes, edges };\r\n  }, [dbNodes, getNodeId, filterConditions]);\r\n\r\n  useEffect(() => {\r\n    const data = { nodes, edges };\r\n    const options = {\r\n      layout: {\r\n        randomSeed: 1 // 고정 배치\r\n      },\r\n      nodes: {\r\n        shape: \"image\",\r\n        brokenImage: getNodeImage({}),\r\n        size: 30,\r\n        borderWidth: 2,\r\n        color: { border: \"#b39ddb\" },\r\n        font: { size: 18, color: \"#222\" }\r\n      },\r\n      edges: {\r\n        // edge별 스타일은 edges 배열에서 개별적으로 적용됨\r\n      },\r\n      physics: true // 물리 엔진 활성화\r\n    };\r\n    if (containerRef.current && !networkRef.current) {\r\n      networkRef.current = new Network(containerRef.current, data, options);\r\n      networkRef.current.on('click', function(params) {\r\n        if (params.nodes && params.nodes.length > 0) {\r\n          const nodeId = params.nodes[0];\r\n          const nodeData = nodes.find(n => n.id === nodeId);\r\n          // 트리 형태로 연결된 모든 노드 탐색 (BFS)\r\n          const visited = new Set();\r\n          const queue = [nodeId];\r\n          while (queue.length > 0) {\r\n            const currentId = queue.shift();\r\n            if (!visited.has(currentId)) {\r\n              visited.add(currentId);\r\n              edges.forEach(e => {\r\n                if (e.from === currentId && !visited.has(e.to)) {\r\n                  queue.push(e.to);\r\n                }\r\n                if (e.to === currentId && !visited.has(e.from)) {\r\n                  queue.push(e.from);\r\n                }\r\n              });\r\n            }\r\n          }\r\n          const connectedIds = Array.from(visited).filter(id => id !== nodeId);\r\n          const connectedCount = connectedIds.length;\r\n          // 연결된 노드의 ip/label을 nodes에서 직접 추출\r\n          const ipSet = new Set();\r\n          connectedIds.forEach(cid => {\r\n            const foundNode = nodes.find(n => n.id === cid);\r\n            if (foundNode?.label) ipSet.add(foundNode.label);\r\n            if (foundNode?.ip) ipSet.add(foundNode.ip);\r\n          });\r\n          // 클릭한 노드의 ip/label 구하기\r\n          let clickedIp = nodeData?.ip || nodeData?.label;\r\n          // 클릭한 노드 ip/label을 목록에서 제외\r\n          const connectedIps = Array.from(ipSet).filter(ip => ip !== clickedIp);\r\n          // 클릭한 노드의 src_IP, dst_IP, edge 정보만 전달\r\n          const clickedItem = dbNodes.find(item => {\r\n            return getNodeId(item.src_IP) === nodeId || getNodeId(item.dst_IP) === nodeId;\r\n          });\r\n          if (onNodeClick) {\r\n            onNodeClick({\r\n              ...nodeData,\r\n              connectedCount,\r\n              connectedIps,\r\n              dbInfo: clickedItem ? [{\r\n                src_IP: clickedItem.src_IP,\r\n                dst_IP: clickedItem.dst_IP,\r\n                edge: clickedItem.edge\r\n              }] : []\r\n            });\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // 이후에는 setData 호출하지 않음 (최초 렌더만)\r\n    return () => {\r\n      if (networkRef.current) {\r\n        networkRef.current.destroy();\r\n        networkRef.current = null;\r\n      }\r\n    };\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [dbNodes, nodes, edges]);\r\n\r\n  return (\r\n    <div className=\"target-graph-canvas\" ref={containerRef} />\r\n  );\r\n});\r\n\r\nTargetGraph2D.displayName = 'TargetGraph2D';\r\n\r\nexport default TargetGraph2D;\r\n","// vis-network edge 스타일 유틸리티\r\n// edge 객체의 속성에 따라 vis-network 스타일을 반환\r\n\r\nexport function getEdgeStyle(edge) {\r\n  return {\r\n    dashes: edge.edgeType === 'dashed' || edge.isDashed === true,\r\n    color: edge.color || '#333',\r\n    width: edge.width || 2,\r\n    arrows: edge.arrows || 'to',\r\n    // 필요시 추가 스타일 속성\r\n  };\r\n}\r\n"],"names":["getNodeImage","node","type","TargetGraph2D","React","memo","dbNodes","onNodeClick","filterConditions","containerRef","useRef","networkRef","getNodeId","useCallback","String","__id","id","ip","index","JSON","stringify","nodes","edges","useMemo","forEach","item","edge","src_IP","dst_IP","srcId","dstId","degreeScore","degree_score","edgeType","connectionType","style","dashes","isDashed","color","width","arrows","push","from","to","length","Math","random","nid","some","n","imageSrc","minSize","maxSize","score","con_score","max","min","dynamicSize","label","shape","image","size","useEffect","data","options","layout","randomSeed","brokenImage","borderWidth","border","font","physics","current","Network","on","params","nodeId","nodeData","find","visited","Set","queue","currentId","shift","has","add","e","connectedIds","Array","filter","connectedCount","ipSet","cid","foundNode","clickedIp","connectedIps","clickedItem","dbInfo","destroy","jsx","className","ref","displayName"],"mappings":"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"}